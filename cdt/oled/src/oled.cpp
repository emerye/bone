#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>
#include <wiringPi.h>
#include <wiringPiSPI.h>
#include <inttypes.h>
#include "SSD1309.h"

#define RESETLINE 29
#define DCLINE 28 


//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Global Variables
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#define XLevelL         0x00
#define XLevelH         0x10
#define XLevel          ((XLevelH&0x0F)*16+XLevelL)
#define Max_Column      128
#define Max_Row         64
#define Brightness      0x8F


unsigned char spiBuffer[20];	//Buffer to hold SPI data

int spiFD;
int rotation = 0;

unsigned char picBuf[1024]; 

#define ssd1306_swap(a, b) { int16_t t = a; a = b; b = t; }
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }

unsigned char buffer[1024];

unsigned char fbuffer[1024];

unsigned char pic[]=
{/*--ER-OLED015-2.bmp  --*/
/*--  128x64  --*/
0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x21,0xFD,0x21,0xE1,0x01,
0xF9,0x49,0x49,0x49,0xF9,0x01,0x01,0x01,0x01,0xFD,0x45,0x45,0x45,0x45,0x45,0x45,
0xFD,0x01,0x01,0x09,0x89,0xC9,0xA9,0x99,0xED,0x89,0x89,0x89,0x89,0x09,0x01,0x11,
0x11,0x11,0x11,0xF1,0x55,0x59,0x51,0xD1,0x19,0x11,0x01,0x29,0xA9,0xF9,0xA5,0x25,
0x01,0x49,0x91,0x01,0xFD,0x01,0x01,0x11,0x11,0xFD,0x91,0x01,0x91,0x91,0xFD,0x91,
0x91,0x11,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x07,0x00,0x1F,0x10,
0x17,0x12,0x12,0x12,0x17,0x18,0x00,0x00,0x00,0x1F,0x08,0x08,0x08,0x08,0x08,0x08,
0x1F,0x00,0x00,0x08,0x08,0x04,0x02,0x10,0x1F,0x00,0x01,0x02,0x04,0x08,0x00,0x10,
0x10,0x08,0x06,0x01,0x10,0x10,0x10,0x0F,0x00,0x00,0x00,0x06,0x01,0x1F,0x00,0x01,
0x02,0x02,0x02,0x02,0x1F,0x01,0x00,0x11,0x11,0x1F,0x00,0x10,0x11,0x0A,0x04,0x0A,
0x11,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0xFE,0x92,0x92,0x92,0x92,0x80,0x70,0x2C,0x22,0x2C,0x70,0x80,
0x4C,0x92,0x92,0x64,0x00,0x02,0x02,0xFE,0x02,0x02,0x00,0xFE,0x12,0x12,0x32,0xCC,
0x00,0x00,0xFE,0x00,0x00,0x4C,0x92,0x92,0x64,0x00,0x00,0xFE,0x00,0x00,0xFE,0x0C,
0x10,0x60,0xFE,0x00,0x00,0x7C,0x82,0x82,0x92,0x74,0x00,0x00,0x00,0x00,0x02,0x02,
0xFE,0x02,0x02,0x00,0xFE,0x92,0x92,0x92,0x92,0x00,0x7C,0x82,0x82,0x82,0x44,0x00,
0x00,0xFE,0x10,0x10,0x10,0xFE,0x00,0x00,0x80,0x00,0x00,0x7C,0x82,0x82,0x82,0x44,
0x00,0x00,0x7C,0x82,0x82,0x82,0x7C,0x00,0x00,0x80,0x00,0x00,0x80,0x00,0x00,0xFE,
0x80,0x80,0x80,0x02,0x02,0xFE,0x02,0x02,0x00,0xFE,0x82,0x82,0x82,0x7C,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC0,0x20,0x00,0x10,0x08,0xC8,0xC8,0x48,0x48,0x48,0x08,0xC8,
0xC8,0x48,0x48,0xC8,0x88,0x08,0x08,0x08,0x08,0x08,0x08,0x88,0xC8,0x48,0xC8,0x88,
0x08,0x08,0xC8,0xC8,0x08,0x08,0x08,0x08,0x08,0xC8,0xC8,0x48,0x48,0x48,0x08,0xC8,
0xC8,0x48,0x48,0xC8,0x88,0x08,0x88,0xC8,0x48,0xC8,0x88,0x08,0x08,0x88,0xC8,0xC8,
0x08,0x08,0x08,0xC8,0xC8,0x48,0x48,0x08,0x08,0x08,0x08,0x08,0x88,0xC8,0x48,0xC8,
0x88,0x08,0x10,0x20,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0F,0x30,0x40,0x00,0x80,0x00,0x3F,0x3F,0x22,0x22,0x22,0x00,0x3F,
0x3F,0x04,0x0C,0x1F,0x33,0x20,0x08,0x08,0x08,0x00,0x0F,0x1F,0x30,0x20,0x30,0x1F,
0x0F,0x00,0x3F,0x3F,0x20,0x20,0x20,0x20,0x00,0x3F,0x3F,0x22,0x22,0x22,0x00,0x3F,
0x3F,0x20,0x20,0x3F,0x1F,0x00,0x1F,0x3F,0x20,0x3F,0x1F,0x00,0x03,0x01,0x3F,0x3F,
0x00,0x00,0x17,0x33,0x22,0x3E,0x1C,0x00,0x08,0x08,0x08,0x00,0x30,0x38,0x2C,0x27,
0x23,0x00,0x80,0x40,0x40,0x30,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x7F,0x00,
0x00,0x00,0x40,0x00,0x2C,0x47,0x45,0x39,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x40,0x20,0xF0,0x00,0x00,0x20,0x10,0x90,0x60,0x00,0x60,0x90,0x90,
0x60,0x00,0x00,0x30,0x40,0xC0,0x30,0x00,0xE1,0x91,0x91,0x21,0x01,0x01,0xC1,0x21,
0xF1,0x01,0x01,0x01,0x81,0x41,0x41,0x41,0xF1,0x01,0x81,0x41,0x41,0x41,0x81,0x41,
0xF1,0x41,0x01,0x81,0x41,0x41,0x41,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0xF1,0x91,0x91,0xF1,0x01,0x01,0xC1,0x31,0x01,0x61,0x91,0x91,
0x21,0x01,0x01,0x01,0x01,0x01,0xF1,0x01,0xC1,0x41,0x41,0x81,0x41,0xE1,0x41,0x01,
0x81,0x41,0x40,0x80,0x00,0xC0,0x40,0x40,0x40,0xE0,0x50,0x00,0x40,0x40,0x40,0xC0,
0x00,0x80,0x40,0x40,0x80,0x00,0x80,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x80,0x80,0x07,0x00,0x80,0x06,0x05,0x84,0x84,0x00,0x83,0x84,0x04,
0x03,0x80,0x00,0x06,0x81,0x81,0x06,0x80,0x83,0x04,0x04,0x83,0x00,0x03,0x82,0x82,
0x07,0x02,0x00,0x00,0xE3,0xE4,0x84,0x84,0x87,0x00,0x03,0x84,0x84,0x04,0x03,0x80,
0x87,0x84,0x80,0x04,0x05,0x05,0x82,0x80,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,
0xE0,0xE0,0x00,0xA0,0xA7,0x00,0x00,0x80,0x80,0x86,0x81,0x00,0x00,0x82,0x84,0x84,
0x83,0x80,0x00,0x00,0xE0,0xE0,0x07,0x00,0x87,0x80,0x80,0x07,0x80,0x87,0x04,0x00,
0x03,0x85,0x85,0x05,0x00,0x07,0x00,0x80,0x80,0x87,0x00,0x00,0x06,0x85,0x85,0x87,
0x80,0x03,0x04,0x84,0x82,0x80,0x83,0x85,0x85,0x85,0x80,0x80,0x00,0x00,0x00,0xFF,
0xFF,0x80,0x80,0x83,0x9F,0x9C,0x8F,0x83,0x8F,0x9C,0x9F,0x83,0x80,0x83,0x9F,0x9C,
0x8F,0x83,0x8F,0x9C,0x9F,0x83,0x80,0x83,0x9F,0x9C,0x8F,0x83,0x8F,0x9C,0x9F,0x83,
0x80,0x98,0x98,0x80,0x9F,0x9F,0x90,0x90,0x9F,0x8F,0x80,0x8F,0x9F,0x90,0x90,0x9F,
0x9F,0xC0,0xC7,0xFF,0xB8,0x9F,0x87,0x80,0x84,0x84,0x84,0x80,0x8F,0x9F,0x90,0x90,
0x9F,0x9F,0x80,0x9F,0x9F,0x80,0x8B,0x9B,0x96,0x96,0x9D,0x8D,0x80,0xFF,0xFF,0x90,
0x90,0x9F,0x8F,0x80,0x9F,0x9F,0x80,0x8D,0x9E,0x92,0x9F,0x9F,0xC0,0xC7,0xFF,0xB8,
0x9F,0x87,0x80,0x98,0x98,0x80,0x8F,0x9F,0x90,0x99,0x89,0x80,0x8F,0x9F,0x90,0x90,
0x9F,0x8F,0x80,0x9F,0x9F,0x80,0x80,0x9F,0x9F,0x80,0x80,0x9F,0x9F,0x80,0x80,0xFF,
};


unsigned char pic2[]=
{/*--ER-OLED015-2.bmp  --*/
/*--  128x64  --*/
0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x21,0xFD,0x21,0xE1,0x01,
0xF9,0x49,0x49,0x49,0xF9,0x01,0x01,0x01,0x01,0xFD,0x45,0x45,0x45,0x45,0x45,0x45,
0xFD,0x01,0x01,0x09,0x89,0xC9,0xA9,0x99,0xED,0x89,0x89,0x89,0x89,0x09,0x01,0x11,
0x11,0x11,0x11,0xF1,0x55,0x59,0x51,0xD1,0x19,0x11,0x01,0x29,0xA9,0xF9,0xA5,0x25,
0x01,0x49,0x91,0x01,0xFD,0x01,0x01,0x11,0x11,0xFD,0x91,0x01,0x91,0x91,0xFD,0x91,
0x91,0x11,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x07,0x00,0x1F,0x10,
0x17,0x12,0x12,0x12,0x17,0x18,0x00,0x00,0x00,0x1F,0x08,0x08,0x08,0x08,0x08,0x08,
0x1F,0x00,0x00,0x08,0x08,0x04,0x02,0x10,0x1F,0x00,0x01,0x02,0x04,0x08,0x00,0x10,
0x10,0x08,0x06,0x01,0x10,0x10,0x10,0x0F,0x00,0x00,0x00,0x06,0x01,0x1F,0x00,0x01,
0x02,0x02,0x02,0x02,0x1F,0x01,0x00,0x11,0x11,0x1F,0x00,0x10,0x11,0x0A,0x04,0x0A,
0x11,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0xFE,0x92,0x92,0x92,0x92,0x80,0x70,0x2C,0x22,0x2C,0x70,0x80,
0x4C,0x92,0x92,0x64,0x00,0x02,0x02,0xFE,0x02,0x02,0x00,0xFE,0x12,0x12,0x32,0xCC,
0x00,0x00,0xFE,0x00,0x00,0x4C,0x92,0x92,0x64,0x00,0x00,0xFE,0x00,0x00,0xFE,0x0C,
0x10,0x60,0xFE,0x00,0x00,0x7C,0x82,0x82,0x92,0x74,0x00,0x00,0x00,0x00,0x02,0x02,
0xFE,0x02,0x02,0x00,0xFE,0x92,0x92,0x92,0x92,0x00,0x7C,0x82,0x82,0x82,0x44,0x00,
0x00,0xFE,0x10,0x10,0x10,0xFE,0x00,0x00,0x80,0x00,0x00,0x7C,0x82,0x82,0x82,0x44,
0x00,0x00,0x7C,0x82,0x82,0x82,0x7C,0x00,0x00,0x80,0x00,0x00,0x80,0x00,0x00,0xFE,
0x80,0x80,0x80,0x02,0x02,0xFE,0x02,0x02,0x00,0xFE,0x82,0x82,0x82,0x7C,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC0,0x20,0x00,0x10,0x08,0xC8,0xC8,0x48,0x48,0x48,0x08,0xC8,
0xC8,0x48,0x48,0xC8,0x88,0x08,0x08,0x08,0x08,0x08,0x08,0x88,0xC8,0x48,0xC8,0x88,
0x08,0x08,0xC8,0xC8,0x08,0x08,0x08,0x08,0x08,0xC8,0xC8,0x48,0x48,0x48,0x08,0xC8,
0xC8,0x48,0x48,0xC8,0x88,0x08,0x88,0xC8,0x48,0xC8,0x88,0x08,0x08,0x88,0xC8,0xC8,
0x08,0x08,0x08,0xC8,0xC8,0x48,0x48,0x08,0x08,0x08,0x08,0x08,0x88,0xC8,0x48,0xC8,
0x88,0x08,0x10,0x20,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0F,0x30,0x40,0x00,0x80,0x00,0x3F,0x3F,0x22,0x22,0x22,0x00,0x3F,
0x3F,0x04,0x0C,0x1F,0x33,0x20,0x08,0x08,0x08,0x00,0x0F,0x1F,0x30,0x20,0x30,0x1F,
0x0F,0x00,0x3F,0x3F,0x20,0x20,0x20,0x20,0x00,0x3F,0x3F,0x22,0x22,0x22,0x00,0x3F,
0x3F,0x20,0x20,0x3F,0x1F,0x00,0x1F,0x3F,0x20,0x3F,0x1F,0x00,0x03,0x01,0x3F,0x3F,
0x00,0x00,0x17,0x33,0x22,0x3E,0x1C,0x00,0x08,0x08,0x08,0x00,0x30,0x38,0x2C,0x27,
0x23,0x00,0x80,0x40,0x40,0x30,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x7F,0x00,
0x00,0x00,0x40,0x00,0x2C,0x47,0x45,0x39,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x40,0x20,0xF0,0x00,0x00,0x20,0x10,0x90,0x60,0x00,0x60,0x90,0x90,
0x60,0x00,0x00,0x30,0x40,0xC0,0x30,0x00,0xE1,0x91,0x91,0x21,0x01,0x01,0xC1,0x21,
0xF1,0x01,0x01,0x01,0x81,0x41,0x41,0x41,0xF1,0x01,0x81,0x41,0x41,0x41,0x81,0x41,
0xF1,0x41,0x01,0x81,0x41,0x41,0x41,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0xF1,0x91,0x91,0xF1,0x01,0x01,0xC1,0x31,0x01,0x61,0x91,0x91,
0x21,0x01,0x01,0x01,0x01,0x01,0xF1,0x01,0xC1,0x41,0x41,0x81,0x41,0xE1,0x41,0x01,
0x81,0x41,0x40,0x80,0x00,0xC0,0x40,0x40,0x40,0xE0,0x50,0x00,0x40,0x40,0x40,0xC0,
0x00,0x80,0x40,0x40,0x80,0x00,0x80,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0x00,0x00,0x80,0x80,0x07,0x00,0x80,0x06,0x05,0x84,0x84,0x00,0x83,0x84,0x04,
0x03,0x80,0x00,0x06,0x81,0x81,0x06,0x80,0x83,0x04,0x04,0x83,0x00,0x03,0x82,0x82,
0x07,0x02,0x00,0x00,0xE3,0xE4,0x84,0x84,0x87,0x00,0x03,0x84,0x84,0x04,0x03,0x80,
0x87,0x84,0x80,0x04,0x05,0x05,0x82,0x80,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,
0xE0,0xE0,0x00,0xA0,0xA7,0x00,0x00,0x80,0x80,0x86,0x81,0x00,0x00,0x82,0x84,0x84,
0x83,0x80,0x00,0x00,0xE0,0xE0,0x07,0x00,0x87,0x80,0x80,0x07,0x80,0x87,0x04,0x00,
0x03,0x85,0x85,0x05,0x00,0x07,0x00,0x80,0x80,0x87,0x00,0x00,0x06,0x85,0x85,0x87,
0x80,0x03,0x04,0x84,0x82,0x80,0x83,0x85,0x85,0x85,0x80,0x80,0x00,0x00,0x00,0xFF,
0xFF,0x80,0x80,0x83,0x9F,0x9C,0x8F,0x83,0x8F,0x9C,0x9F,0x83,0x80,0x83,0x9F,0x9C,
0x8F,0x83,0x8F,0x9C,0x9F,0x83,0x80,0x83,0x9F,0x9C,0x8F,0x83,0x8F,0x9C,0x9F,0x83,
0x80,0x98,0x98,0x80,0x9F,0x9F,0x90,0x90,0x9F,0x8F,0x80,0x8F,0x9F,0x90,0x90,0x9F,
0x9F,0xC0,0xC7,0xFF,0xB8,0x9F,0x87,0x80,0x84,0x84,0x84,0x80,0x8F,0x9F,0x90,0x90,
0x9F,0x9F,0x80,0x9F,0x9F,0x80,0x8B,0x9B,0x96,0x96,0x9D,0x8D,0x80,0xFF,0xFF,0x90,
0x90,0x9F,0x8F,0x80,0x9F,0x9F,0x80,0x8D,0x9E,0x92,0x9F,0x9F,0xC0,0xC7,0xFF,0xB8,
0x9F,0x87,0x80,0x98,0x98,0x80,0x8F,0x9F,0x90,0x99,0x89,0x80,0x8F,0x9F,0x90,0x90,
0x9F,0x8F,0x80,0x9F,0x9F,0x80,0x80,0x9F,0x9F,0x80,0x80,0x9F,0x9F,0x80,0x80,0xFF,
};

#define ssd1306_swap(a, b) { int16_t t = a; a = b; b = t; }

int width() {
	return SSD1309_LCDWIDTH;
}

int height() {
	return(SSD1309_LCDHEIGHT);
}

// Draw a circle outline
void drawCircle(int16_t x0, int16_t y0, int16_t r,
 uint16_t color) {
  int16_t f = 1 - r;
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x = 0;
  int16_t y = r;

  drawPixel(x0  , y0+r, color);
  drawPixel(x0  , y0-r, color);
  drawPixel(x0+r, y0  , color);
  drawPixel(x0-r, y0  , color);

  while (x<y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;

    drawPixel(x0 + x, y0 + y, color);
    drawPixel(x0 - x, y0 + y, color);
    drawPixel(x0 + x, y0 - y, color);
    drawPixel(x0 - x, y0 - y, color);
    drawPixel(x0 + y, y0 + x, color);
    drawPixel(x0 - y, y0 + x, color);
    drawPixel(x0 + y, y0 - x, color);
    drawPixel(x0 - y, y0 - x, color);
  }
}

void drawCircleHelper( int16_t x0, int16_t y0,
 int16_t r, uint8_t cornername, uint16_t color) {
  int16_t f     = 1 - r;
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
  int16_t y     = r;

  while (x<y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f     += ddF_y;
    }
    x++;
    ddF_x += 2;
    f     += ddF_x;
    if (cornername & 0x4) {
      drawPixel(x0 + x, y0 + y, color);
      drawPixel(x0 + y, y0 + x, color);
    }
    if (cornername & 0x2) {
      drawPixel(x0 + x, y0 - y, color);
      drawPixel(x0 + y, y0 - x, color);
    }
    if (cornername & 0x8) {
      drawPixel(x0 - y, y0 + x, color);
      drawPixel(x0 - x, y0 + y, color);
    }
    if (cornername & 0x1) {
      drawPixel(x0 - y, y0 - x, color);
      drawPixel(x0 - x, y0 - y, color);
    }
  }
}

void fillCircle(int16_t x0, int16_t y0, int16_t r,
 uint16_t color) {
  drawFastVLine(x0, y0-r, 2*r+1, color);
  fillCircleHelper(x0, y0, r, 3, 0, color);
}

// Used to do circles and roundrects
void fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
 uint8_t cornername, int16_t delta, uint16_t color) {

  int16_t f     = 1 - r;
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x     = 0;
  int16_t y     = r;

  while (x<y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f     += ddF_y;
    }
    x++;
    ddF_x += 2;
    f     += ddF_x;

    if (cornername & 0x1) {
      drawFastVLine(x0+x, y0-y, 2*y+1+delta, color);
      drawFastVLine(x0+y, y0-x, 2*x+1+delta, color);
    }
    if (cornername & 0x2) {
      drawFastVLine(x0-x, y0-y, 2*y+1+delta, color);
      drawFastVLine(x0-y, y0-x, 2*x+1+delta, color);
    }
  }
}


// Bresenham's algorithm - thx wikpedia
void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
 uint16_t color) {
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    _swap_int16_t(x0, y0);
    _swap_int16_t(x1, y1);
  }

  if (x0 > x1) {
    _swap_int16_t(x0, x1);
    _swap_int16_t(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
      drawPixel(y0, x0, color);
    } else {
      drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}

// Draw a rectangle
void drawRect(int16_t x, int16_t y, int16_t w, int16_t h,
 uint16_t color) {
  drawFastHLine(x, y, w, color);
  drawFastHLine(x, y+h-1, w, color);
  drawFastVLine(x, y, h, color);
  drawFastVLine(x+w-1, y, h, color);
}



// the most basic function, set a single pixel
void drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
    return;

  // check rotation, move pixel around if necessary
  switch (rotation) {
  case 1:
    ssd1306_swap(x, y);
    x = WIDTH - x - 1;
    break;
  case 2:
    x = WIDTH - x - 1;
    y = HEIGHT - y - 1;
    break;
  case 3:
    ssd1306_swap(x, y);
    y = HEIGHT - y - 1;
    break;
  }

  // x is which column
    switch (color)
    {
      case WHITE:   buffer[x+ (y/8)*SSD1309_LCDWIDTH] |=  (1 << (y&7)); break;
      case BLACK:   buffer[x+ (y/8)*SSD1309_LCDWIDTH] &= ~(1 << (y&7)); break;
      case INVERSE: buffer[x+ (y/8)*SSD1309_LCDWIDTH] ^=  (1 << (y&7)); break;
    }

}


void drawFastVLine(int16_t x, int16_t __y, int16_t __h,
		uint16_t color) {

	// do nothing if we're off the left or right side of the screen
	if (x < 0 || x >= WIDTH) {
		return;
	}

	// make sure we don't try to draw below 0
	if (__y < 0) {
		// __y is negative, this will subtract enough from __h to account for __y being 0
		__h += __y;
		__y = 0;

	}

	// make sure we don't go past the height of the display
	if ((__y + __h) > HEIGHT) {
		__h = (HEIGHT - __y);
	}

	// if our height is now negative, punt
	if (__h <= 0) {
		return;
	}

	// this display doesn't need ints for coordinates, use local byte registers for faster juggling
	register uint8_t y = __y;
	register uint8_t h = __h;

	// set up the pointer for fast movement through the buffer
	register uint8_t *pBuf = buffer;
	// adjust the buffer pointer for the current row
	pBuf += ((y / 8) * SSD1309_LCDWIDTH);
	// and offset x columns in
	pBuf += x;

	// do the first partial byte, if necessary - this requires some masking
	register uint8_t mod = (y & 7);
	if (mod) {
		// mask off the high n bits we want to set
		mod = 8 - mod;

		// note - lookup table results in a nearly 10% performance improvement in fill* functions
		// register uint8_t mask = ~(0xFF >> (mod));
		static uint8_t premask[8] = { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC,
				0xFE };
		register uint8_t mask = premask[mod];

		// adjust the mask if we're not going to reach the end of this byte
		if (h < mod) {
			mask &= (0XFF >> (mod - h));
		}

		switch (color) {
		case WHITE:
			*pBuf |= mask;
			break;
		case BLACK:
			*pBuf &= ~mask;
			break;
		case INVERSE:
			*pBuf ^= mask;
			break;
		}

		// fast exit if we're done here!
		if (h < mod) {
			return;
		}

		h -= mod;

		pBuf += SSD1309_LCDWIDTH;
	}
	// write solid bytes while we can - effectively doing 8 rows at a time
	if (h >= 8) {
		if (color == INVERSE) { // separate copy of the code so we don't impact performance of the black/white write version with an extra comparison per loop
			do {
				*pBuf = ~(*pBuf);

				// adjust the buffer forward 8 rows worth of data
				pBuf += SSD1309_LCDWIDTH;

				// adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
				h -= 8;
			} while (h >= 8);
		} else {
			// store a local value to work with
			register uint8_t val = (color == WHITE) ? 255 : 0;

			do {
				// write our value in
				*pBuf = val;

				// adjust the buffer forward 8 rows worth of data
				pBuf += SSD1309_LCDWIDTH;

				// adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
				h -= 8;
			} while (h >= 8);
		}
	}

	// now do the final partial byte, if necessary
	if (h) {
		mod = h & 7;
		// this time we want to mask the low bits of the byte, vs the high bits we did above
		// register uint8_t mask = (1 << mod) - 1;
		// note - lookup table results in a nearly 10% performance improvement in fill* functions
		static uint8_t postmask[8] = { 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F,
				0x7F };
		register uint8_t mask = postmask[mod];
		switch (color) {
		case WHITE:
			*pBuf |= mask;
			break;
		case BLACK:
			*pBuf &= ~mask;
			break;
		case INVERSE:
			*pBuf ^= mask;
			break;
		}
	}
}




void drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
  // Do bounds/limit checks
  if(y < 0 || y >= HEIGHT) { return; }

  // make sure we don't try to draw below 0
  if(x < 0) {
    w += x;
    x = 0;
  }

  // make sure we don't go off the edge of the display
  if( (x + w) > WIDTH) {
    w = (WIDTH - x);
  }

  // if our width is now negative, punt
  if(w <= 0) { return; }

  // set up the pointer for  movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SSD1309_LCDWIDTH);
  // and offset x columns in
  pBuf += x;

  register uint8_t mask = 1 << (y&7);

  switch (color)
  {
  case WHITE:         while(w--) { *pBuf++ |= mask; }; break;
    case BLACK: mask = ~mask;   while(w--) { *pBuf++ &= mask; }; break;
  case INVERSE:         while(w--) { *pBuf++ ^= mask; }; break;
  }
}




void invertDisplay(uint8_t i) {
  if (i) {
    SendByte(COMMAND,SSD1309_INVERTDISPLAY);
  } else {
    SendByte(COMMAND,SSD1309_NORMALDISPLAY);
  }
}


int SendSPIBlock(enum cmd cmdType, unsigned char *spiData, int numBytes)
{
    int error;
    unsigned char spiBuffer[20];
 
    memcpy(spiBuffer, spiData, numBytes); 

    if (cmdType == COMMAND) {
	digitalWrite(DCLINE, LOW);
    } else {
	digitalWrite(DCLINE, HIGH);
    }

    error = wiringPiSPIDataRW(0, spiBuffer, numBytes);
    if (error == -1) {
	printf("Error writing SPI %d\n", error);
        perror("SPI Write"); 
    }
    return error;
}


int SendByte(enum cmd cmdType, int data)
{
   spiBuffer[0] = (unsigned char) (data & 0xFF);   
   return (SendSPIBlock(cmdType, spiBuffer, 1));    
}
	

void drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color) {
  bool bSwap = false;
  int rotation = 0;

  switch(rotation) {
    case 0:
      // 0 degree rotation, do nothing
      break;
    case 1:
      // 90 degree rotation, swap x & y for rotation, then invert x
      bSwap = true;
      ssd1306_swap(x, y);
      x = WIDTH - x - 1;
      break;
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
      x -= (w-1);
      break;
    case 3:
      // 270 degree rotation, swap x & y for rotation, then invert y  and adjust y for w (not to become h)
      bSwap = true;
      ssd1306_swap(x, y);
      y = HEIGHT - y - 1;
      y -= (w-1);
      break;
  }

  if(bSwap) {
 //   drawFastVLineInternal(x, y, w, color);
  } else {
 //   drawFastHLineInternal(x, y, w, color);
  }
}

void initDisplay()
{
    digitalWrite(RESETLINE, HIGH);
    digitalWrite(RESETLINE, LOW);
    usleep(15000); 
    digitalWrite(RESETLINE, HIGH);

    usleep(1000);

    SendByte(COMMAND, 0xFD);	// Set Command Lock
    SendByte(COMMAND, 0x12);	//   Default => 0x12
    //     0x12 => Driver IC interface is unlocked from entering command.
    //     0x16 => All Commands are locked except 0xFD.

    SendByte(COMMAND, SSD1309_DISPLAYOFF);	//--turn off oled panel

    SendByte(COMMAND, SSD1309_SETDISPLAYCLOCKDIV);	// Set Display Clock Divide Ratio / Oscillator Frequency
    SendByte(COMMAND, 0xa0);	//   Default => 0x70
    //     D[3:0] => Display Clock Divider
    //     D[7:4] => Oscillator Frequency

    SendByte(COMMAND, SSD1309_SETMULTIPLEX);	//--set multiplex ratio(1 to 64)
    SendByte(COMMAND, 0x3f);	//--1/64 duty

    SendByte(COMMAND, SSD1309_SETDISPLAYOFFSET);	//Set Display Offset
    SendByte(COMMAND, 0x00);

    SendByte(COMMAND, 0x40);	// Set Display Start Line

    SendByte(COMMAND, SSD1309_MEMORYMODE);	// Set Memory Addressing Mode
    SendByte(COMMAND, 0x02);	//   Default => 0x02
    //     0x00 => Horizontal Addressing Mode
    //     0x01 => Vertical Addressing Mode
    //     0x02 => Page Addressing Mode


    SendByte(COMMAND, 0xa1);	//--set segment re-map 128 to 0

    SendByte(COMMAND, 0xC8);	//--Set COM Output Scan Direction 64 to 1


    SendByte(COMMAND, 0xda);	//--Set COM Pins Hardware Configuration
    SendByte(COMMAND, 0x12);	//     Disable COM Left/Right Re-Map   Alternative COM Pin Configuration


    SendByte(COMMAND, SSD1309_SETCONTRAST);	//--set contrast control register
    SendByte(COMMAND, 0x8F);    // Maximum


    SendByte(COMMAND, 0xD9);	// Set Pre-Charge Period
    SendByte(COMMAND, 0x25);	//   Default => 0x22 (2 Display Clocks [Phase 2] / 2 Display Clocks [Phase 1])
    //     D[3:0] => Phase 1 Period in 1~15 Display Clocks
    //     D[7:4] => Phase 2 Period in 1~15 Display Clocks

    SendByte(COMMAND, 0xDB);	// Set VCOMH Deselect Level
    SendByte(COMMAND, 0x34);	//   Default => 0x34 (0.78*VCC)


    SendByte(COMMAND, 0xad);	//--Set Master Configuration
    SendByte(COMMAND, 0x8e);	//--

    SendByte(COMMAND, 0xd8);	//--Set Area Color Mode On/Off & Low Power Display Mode
    SendByte(COMMAND, 0x05);	//

    SendByte(COMMAND, 0xa4);	//Disable Entire Display On     

    SendByte(COMMAND, 0xa6);	//--set normal display

    SendByte(COMMAND, 0xaf);	//--turn on oled panel
}



//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Instruction Setting
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void Set_Start_Column(unsigned char d)
{
        SendByte(COMMAND, 0x00+d%16);               // Set Lower Column Start Address for Page Addressing Mode
                                                //   Default => 0x00
        SendByte(COMMAND,0x10+d/16);               // Set Higher Column Start Address for Page Addressing Mode
                                                //   Default => 0x10
}


void Set_Addressing_Mode(unsigned char d)
{
        SendByte(COMMAND, 0x20);                    // Set Memory Addressing Mode
        SendByte(COMMAND, d);                       //   Default => 0x02
                                                //     0x00 => Horizontal Addressing Mode
                                                //     0x01 => Vertical Addressing Mode
                                                //     0x02 => Page Addressing Mode
}


void Set_Column_Address(unsigned char a, unsigned char b)
{
        SendByte(COMMAND, 0x21);                    // Set Column Address
        SendByte(COMMAND, a);                       //   Default => 0x00 (Column Start Address)
        SendByte(COMMAND, b);                       //   Default => 0x7F (Column End Address)
}


void Set_Page_Address(unsigned char a, unsigned char b)
{
        SendByte(COMMAND,0x22);                    // Set Page Address
        SendByte(COMMAND, a);                       //   Default => 0x00 (Page Start Address)
        SendByte(COMMAND, b);                       //   Default => 0x07 (Page End Address)
}



void Display_Picture(unsigned char *p) 
{unsigned char *picture;
    unsigned char i,j;
                picture=p;
        
        for(i=0;i<0x08;i++)
        {
        //Set_Start_Page(i);
        SendByte(COMMAND, 0xB0 | i); 
        Set_Start_Column(XLevel);
        for(j=0;j<0x80;j++)
                {
                    SendByte(DATA, *picture);
                        picture++;
                }
        }
}


void init_Hardware(void)
{
    int status; 

    pinMode(RESETLINE,OUTPUT);
    pinMode(DCLINE,OUTPUT);  
    status = wiringPiSPISetup(0,1000000*2); 
    if(status < 1) {
      perror("Error opening SPI"); 
    }  
}

void setContrast(unsigned char level) {
  unsigned char buffer[3];
  buffer[0] = 0x81;
  buffer[1] = level;
  SendSPIBlock(COMMAND,buffer,2);  
}

void fBuffer() {
	int h,v;

	for (v=0; v<8; v++) {
		for (h=0; h<128; h++) {
			if(v==0) {
				fbuffer[h] = 0x55;
			}
			if(v==1) {
				fbuffer[v*128 + h] = 0xFF;
			}
		}
	}

}

int main(int argc, char **argv)
{
    wiringPiSetup(); 
    init_Hardware();
    initDisplay();
    setContrast(0xBB);
    
    int picSize = sizeof(pic);
    printf("Size %d\n", picSize);
  //  Display_Picture(pic);
  //  sleep(2);

 //   SendByte(COMMAND,SSD1309_INVERTDISPLAY);
    printf("Size of pic %d\n",sizeof(pic)); 
    fBuffer();
    Display_Picture(fbuffer);
    drawFastHLine(0,63,128,WHITE);
    drawFastVLine(15, 8, 30, WHITE);
    drawCircle(32,32,16,WHITE);
    drawLine(0, 0, 60, 100,
     WHITE);
    drawRect(10,10,50,50,WHITE);

    Display_Picture(buffer);
    return 0;
}
